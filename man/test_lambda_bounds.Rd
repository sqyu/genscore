% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genscore.R
\name{test_lambda_bounds}
\alias{test_lambda_bounds}
\title{Searches for a tight bound for \eqn{\lambda_{\boldsymbol{K}}}{\lambda_K} that gives the empty or complete graph starting from a given lambda with a given step size}
\usage{
test_lambda_bounds(elts, symmetric, lambda = 1, lambda_ratio = 1,
  step = 2, lower = TRUE, verbose = TRUE, tol = 1e-06,
  maxit = 10000, cur_res = NULL)
}
\arguments{
\item{elts}{A list, elements necessary for calculations returned by \code{get_elts()}.}

\item{symmetric}{A string. If equals \code{"symmetric"}, estimates the minimizer \eqn{\mathbf{K}}{K} over all symmetric matrices; if \code{"and"} or \code{"or"}, use the "and"/"or" rule to get the support}

\item{lambda}{A number, the initial searching point for \eqn{\lambda_{\mathbf{K}}}{\lambda_K}.}

\item{lambda_ratio}{A positive number (or \code{Inf}), the fixed ratio \eqn{\lambda_{\mathbf{K}}}{\lambda_K} and \eqn{\lambda_{\boldsymbol{\eta}}}{\lambda_\eta}, if \eqn{\lambda_{\boldsymbol{\eta}}\neq 0}{\lambda_\eta!=0} (non-profiled) in the non-centered setting.}

\item{step}{A number, the multiplicative constant applied to lambda at each iteration. Must be strictly larger than 1.}

\item{lower}{A boolean. If \code{TRUE}, finds the largest possible lambda that gives the complete graph (a \eqn{lower} bound). If \code{FALSE}, finds the smallest possible lambda that gives the empty graph (an \eqn{upper} bound).}

\item{verbose}{Optional. A boolean. If \code{TRUE}, prints out the lambda value at each iteration.}

\item{tol}{Optional. A number, the tolerance parameter.}

\item{maxit}{Optional. A positive integer, the maximum number of iterations in model fitting for each lambda.}

\item{cur_res}{Optional. A list, current results returned from a previous lambda. If provided, used as a warm start. Default to \code{NULL}.}
}
\value{
\item{lambda}{A number, the best \code{lambda} that produces the desired number of edges. \code{1e-10} or \code{1e15} is returned if out of bound.}
    \item{cur_res}{A list, results for this \code{lambda}. May be \code{NULL} if \code{lambda} is out of bound.}
}
\description{
Searches for the smallest lambda that gives the empty graph (if \code{lower == FALSE}) or the largest that gives the complete graph (if \code{lower == TRUE}) starting from the given lambda, each time updating by multiplying or dividing by \code{step} depending on the search direction.
}
\examples{
if (!requireNamespace("tmvtnorm", quietly = TRUE)){
  stop("Please install package \\"tmvtnorm\\" first.", call. = FALSE)
}
#require(tmvtnorm)
#n <- 50
#p <- 30
#h_hp <- get_h_hp("min_pow", 1, 3)
#mu <- rep(0, p)
#K <- diag(p)
#dm <- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
#x <- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
#       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
#       burn.in.samples = 100, thinning = 10)

#elts_NC_NP <- get_elts(h_hp$h, h_hp$hp, x, setting="trun_gaussian",
#                centered=FALSE, profiled=FALSE, diag=dm)
#lambda_cur_res <- test_lambda_bounds(elts_NC_NP, "symmetric", lambda=1,
#                       lambda_ratio=1, step=1.5, lower=TRUE, cur_res=NULL)
#lambda_cur_res2 <- test_lambda_bounds(elts_NC_NP, "symmetric", lambda=1,
#                       lambda_ratio=1, step=1.5, lower=FALSE, cur_res=lambda_cur_res$cur_res)
}
