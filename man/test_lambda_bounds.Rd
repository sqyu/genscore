% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genscore.R
\name{test_lambda_bounds}
\alias{test_lambda_bounds}
\title{Searches for a tight bound for \eqn{\lambda_{\boldsymbol{K}}}{\lambda_K} that gives the empty or complete graph starting from a given lambda with a given step size}
\usage{
test_lambda_bounds(
  elts,
  symmetric,
  lambda = 1,
  lambda_ratio = 1,
  step = 2,
  lower = TRUE,
  verbose = TRUE,
  tol = 1e-06,
  maxit = 10000,
  cur_res = NULL
)
}
\arguments{
\item{elts}{A list, elements necessary for calculations returned by \code{get_elts()}.}

\item{symmetric}{A string. If equals \code{"symmetric"}, estimates the minimizer \eqn{\mathbf{K}}{K} over all symmetric matrices; if \code{"and"} or \code{"or"}, use the "and"/"or" rule to get the support}

\item{lambda}{A number, the initial searching point for \eqn{\lambda_{\mathbf{K}}}{\lambda_K}.}

\item{lambda_ratio}{A positive number (or \code{Inf}), the fixed ratio \eqn{\lambda_{\mathbf{K}}}{\lambda_K} and \eqn{\lambda_{\boldsymbol{\eta}}}{\lambda_\eta}, if \eqn{\lambda_{\boldsymbol{\eta}}\neq 0}{\lambda_\eta!=0} (non-profiled) in the non-centered setting.}

\item{step}{A number, the multiplicative constant applied to lambda at each iteration. Must be strictly larger than 1.}

\item{lower}{A boolean. If \code{TRUE}, finds the largest possible lambda that gives the complete graph (a \eqn{lower} bound). If \code{FALSE}, finds the smallest possible lambda that gives the empty graph (an \eqn{upper} bound).}

\item{verbose}{Optional. A boolean. If \code{TRUE}, prints out the lambda value at each iteration.}

\item{tol}{Optional. A number, the tolerance parameter.}

\item{maxit}{Optional. A positive integer, the maximum number of iterations in model fitting for each lambda.}

\item{cur_res}{Optional. A list, current results returned from a previous lambda. If provided, used as a warm start. Default to \code{NULL}.}
}
\value{
\item{lambda}{A number, the best \code{lambda} that produces the desired number of edges. \code{1e-10} or \code{1e15} is returned if out of bound.}
    \item{cur_res}{A list, results for this \code{lambda}. May be \code{NULL} if \code{lambda} is out of bound.}
}
\description{
Searches for the smallest lambda that gives the empty graph (if \code{lower == FALSE}) or the largest that gives the complete graph (if \code{lower == TRUE}) starting from the given lambda, each time updating by multiplying or dividing by \code{step} depending on the search direction.
}
\examples{
# Examples are shown for Gaussian truncated to R+^p only. For other distributions
#   on other types of domains, please refer to \code{gen()} or \code{get_elts()}, as the 
#   way to call this function (\code{test_lambda_bounds()}) is exactly the same in those cases.
if (!requireNamespace("tmvtnorm", quietly = TRUE))
   stop("Please install package \"tmvtnorm\".")
n <- 50
p <- 30
domain <- make_domain("R+", p=p)
mu <- rep(0, p)
K <- diag(p)
x <- tmvtnorm::rtmvnorm(n, mean = mu, sigma = solve(K),
       lower = rep(0, p), upper = rep(Inf, p), algorithm = "gibbs",
       burn.in.samples = 100, thinning = 10)

h_hp <- get_h_hp("min_pow", 1, 3)
dm <- 1 + (1-1/(1+4*exp(1)*max(6*log(p)/n, sqrt(6*log(p)/n))))
elts_gauss_np <- get_elts(h_hp, x, setting="gaussian", domain=domain,
                 centered=FALSE, profiled=FALSE, diag=dm)
lambda_cur_res <- test_lambda_bounds(elts_gauss_np, "symmetric", lambda=1,
                  lambda_ratio=1, step=1.5, lower=TRUE, cur_res=NULL)
lambda_cur_res2 <- test_lambda_bounds(elts_gauss_np, "symmetric", lambda=1,
                  lambda_ratio=1, step=1.5, lower=FALSE, cur_res=lambda_cur_res$cur_res)
}
